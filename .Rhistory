# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
reverseComplement(ACACATGAGAGCTGTCGATAGATCATTCCG)
library(Biostrings)
reverseComplement(ACACATGAGAGCTGTCGATAGATCATTCCG)
reverseComplement('ACACATGAGAGCTGTCGATAGATCATTCCG')
# 创建 DNA 序列对象
dna <- DNAString("ACACATGAGAGCTGTCGATAGATCATTCCG")
# 创建 DNA 序列对象
dna <- DNAString("ACACATGAGAGCTGTCGATAGATCATTCCG")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("CGGAATGATCTATCGACAGCTCTCATGTGT")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("GGCCGAGGACTCCTGCTCCGCTGCGGAAGT")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("GCCTTACTAGATAGCTGTCGAGAGTACACA")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("GCCTTACTAGATAGCTGTCGAGAGTACACA")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("GCCTTACTAGATAGCTGTCGAGAGTACACA")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("CGGAATGATCTATCGACAGCTCTCATGTGT")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("ACTTCCGCAGCGGAGCAGGAGTCCTCGGCC")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("GGCCGAGGACTCCTGCTCCGCTGCGGAAGT")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("GCCTGGAGATACATGCACATTACGGCAGCG")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("AGACATGAGGCGCATCCAGAGACGACGCAC")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("CCTGCTGATCTGTTCCCAGGACTACTGTCT")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("ACCTGACTATTCTAGTTGAACGACTGTCGC")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
# 创建 DNA 序列对象
dna <- DNAString("CCTGCTGATCTGTTCCCAGGACTACTGTCT")
# 获取互补序列
complement_seq <- complement(dna)
# 获取反向互补序列
reverse_complement_seq <- reverseComplement(dna)
# 打印结果
cat("原始序列:           ", as.character(dna), "\n")
cat("互补序列 (3'→5'):   ", as.character(complement_seq), "\n")
cat("反向互补序列 (5'→3'):", as.character(reverse_complement_seq), "\n")
usethis::install_github("tzina97/netMHCpan")
install.packages("remotes")
remotes::install_github("tzina97/netMHCpan")
library(netmhcpan)
library(netmhcpan)
library(biomaRt)
# 设置人类与酵母的数据集
human <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
yeast <- useMart("ensembl", dataset = "scerevisiae_gene_ensembl")
# 查询酵母中的同源基因
human_genes <- c("FDX1", "LIAS", "LIPT1", "DLD", "DLAT",
"PDHA1", "PDHB", "MTF1", "GLS", "CDKN2A")
orthologs <- getLDS(attributes = c("hgnc_symbol"),
filters = "hgnc_symbol",
values = human_genes,
mart = human,
attributesL = c("external_gene_name"),
martL = yeast)
library(circlize)
data <- data.frame(
source = c("ActDC", "TAMs", "cDC2", "Eff.CD8+", "Dyst.CD8+"),
target = c("Eff.CD8+", "Eff.CD8+", "Act.CD8+", "TAMs", "ActDC"),
ligand = c("Icam1", "Cd274", "Itgb2", "Pdcd1", "Cd47"),
receptor = c("Itgb2", "Pdcd1", "Cd47", "Cd274", "Sirpa"),
weight = c(0.4, 0.5, 0.6, 0.7, 0.3)
)
View(data)
group_colors <- c(
"ActDC" = "#8DD3C7",
"TAMs" = "#BEBADA",
"cDC2" = "#FB8072",
"Eff.CD8+" = "#80B1D3",
"Dyst.CD8+" = "#FDB462"
)
chordDiagram(
data[, c("source", "target", "weight")],
grid.col = group_colors,
transparency = 0.3,
annotationTrack = c("name", "grid"),
preAllocateTracks = list(track.height = 0.1)
)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.name <- get.cell.meta.data("sector.index")
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(5),
sector.name, facing = "clockwise", niceFacing = TRUE,
adj = c(0, 0.5))
}, bg.border = NA)
data <- data.frame(
source_cell = c("TAMs","ActDC","cDC2"),
source_gene = c("Cd274","Icam1","Cd86"),
target_cell = c("Eff.CD8+","cDC2","Act.CD8+"),
target_gene = c("Pdcd1","Itgb2","Ctla4"),
weight = c(0.6, 0.5, 0.7)
)
source_sector <- paste0(data$source_cell, "_", data$source_gene)
target_sector <- paste0(data$target_cell, "_", data$target_gene)
sectors <- unique(c(source_sector, target_sector))
cell_colors <- c(
"ActDC"="#A6CEE3",
"cDC2"="#1F78B4",
"TAMs"="#B2DF8A",
"Eff.CD8+"="#FB9A99",
"Act.CD8+"="#E31A1C"
)
sector_colors <- sapply(sectors, function(s){
cell <- strsplit(s, "_")[[1]][1]
cell_colors[cell]
})
circos.clear()
circos.par(start.degree = 90, gap.after = c(rep(1, length(sectors)-1), 8))
chordDiagram(
x = data.frame(from = source_sector, to = target_sector, value = data$weight),
grid.col = sector_colors,
directional = 1,
direction.type = c("arrows"),
link.arr.type = "big.arrow",
link.sort = TRUE,
transparency = 0.25,
annotationTrack = "grid",
preAllocateTracks = list(track.height = 0.1)
)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.name <- get.cell.meta.data("sector.index")
cell_name <- strsplit(sector.name, "_")[[1]][1]
gene_name <- strsplit(sector.name, "_")[[1]][2]
# 绘制刻度标签（基因名）
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(2),
gene_name, facing = "clockwise", niceFacing = TRUE, cex = 0.5)
# 在首个基因扇区加细胞群标签
if (gene_name == unique(data$source_gene[data$source_cell == cell_name])[1]) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(5),
cell_name, facing = "clockwise", niceFacing = TRUE, font = 2, cex = 0.8)
}
}, bg.border = NA)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.name <- get.cell.meta.data("sector.index")
cell_name <- strsplit(sector.name, "_")[[1]][1]
gene_name <- strsplit(sector.name, "_")[[1]][2]
# 绘制刻度标签（基因名）
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(2),
gene_name, facing = "clockwise", niceFacing = TRUE, cex = 0.5)
# 在首个基因扇区加细胞群标签
if (gene_name == unique(data$source_gene[data$source_cell == cell_name])[1]) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(5),
cell_name, facing = "clockwise", niceFacing = TRUE, font = 2, cex = 0.8)
}
}, bg.border = NA)
library(circlize)
library(dplyr)
data <- data.frame(
source_cell = c("TAMs","ActDC","cDC2"),
source_gene = c("Cd274","Icam1","Cd86"),
target_cell = c("Eff.CD8+","cDC2","Act.CD8+"),
target_gene = c("Pdcd1","Itgb2","Ctla4"),
weight = c(0.6, 0.5, 0.7)
)
source_sector <- paste0(data$source_cell, "_", data$source_gene)
target_sector <- paste0(data$target_cell, "_", data$target_gene)
sectors <- unique(c(source_sector, target_sector))
cell_colors <- c(
"ActDC"="#A6CEE3",
"cDC2"="#1F78B4",
"TAMs"="#B2DF8A",
"Eff.CD8+"="#FB9A99",
"Act.CD8+"="#E31A1C"
)
sector_colors <- sapply(sectors, function(s){
cell <- strsplit(s, "_")[[1]][1]
cell_colors[cell]
})
circos.clear()
circos.par(start.degree = 90, gap.after = c(rep(1, length(sectors)-1), 8))
chordDiagram(
x = data.frame(from = source_sector, to = target_sector, value = data$weight),
grid.col = sector_colors,
directional = 1,
direction.type = c("arrows"),
link.arr.type = "big.arrow",
link.sort = TRUE,
transparency = 0.25,
annotationTrack = "grid",
preAllocateTracks = list(track.height = 0.1)
)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
sector.name <- get.cell.meta.data("sector.index")
cell_name <- strsplit(sector.name, "_")[[1]][1]
gene_name <- strsplit(sector.name, "_")[[1]][2]
# 绘制刻度标签（基因名）
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(2),
gene_name, facing = "clockwise", niceFacing = TRUE, cex = 0.5)
# 在首个基因扇区加细胞群标签
if (gene_name == unique(data$source_gene[data$source_cell == cell_name])[1]) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + mm_y(5),
cell_name, facing = "clockwise", niceFacing = TRUE, font = 2, cex = 0.8)
}
}, bg.border = NA)
# install.packages("circlize")
library(circlize)
# =============== 1) 准备数据 ===============
# groups: 每个大类（细胞群）对应的基因列表（顺序即外圈小刻度顺序）
groups <- list(
"Act. CD8+"   = c("Tigit","Penk","Gnas","Cd47","Ccl3","Ccl4"),
"Eff. CD8+"   = c("Anxa2","B2m","Ccl3","Ccl5","Gzmb","Lef1","Itgal"),
"Ccl5+ Eff. CD8+" = c("Ccl5","Gzmb","Nkg7"),
"Dysf. CD8+"  = c("Anxa2","Ccl3","Ccl5","Gzmb","Lgals1"),
"cDC1"        = c("Amfr","Cd74","Dpp4","Ogfr"),
"TAMs"        = c("Trem2","Sirpa","Lsp1","Icam1","Tnf","Tnfrsf1b"),
"cDC2"        = c("Siglec1","Cd209","Nectin1","Icam1","Itgb2"),
"ActDC"       = c("Anxa2","App","Cd209","Icam1")
)
# 交互弦（示例；用你真实的互作/权重数据替换）
# from_gene / to_gene 的命名采用 "大类|基因" 形式以唯一标识小扇区
links <- data.frame(
from_group = c("TAMs","ActDC","cDC2","Eff. CD8+","Dysf. CD8+"),
from_gene  = c("Cd274","Icam1","Itgb2","Gzmb","Lgals1"),
to_group   = c("Eff. CD8+","cDC2","Act. CD8+","TAMs","ActDC"),
to_gene    = c("Pdcd1","Itgb2","Cd47","Cd274","Sirpa"),
weight     = c(0.55, 0.42, 0.38, 0.63, 0.30)
)
# =============== 2) 生成“小扇区”序列与间距 ===============
# 把每个基因变成一个 sector：  sector_id = "Group|Gene"
sector_ids_by_group <- lapply(names(groups), function(g){
paste(g, groups[[g]], sep="|")
})
names(sector_ids_by_group) <- names(groups)
sector_order <- unlist(sector_ids_by_group, use.names = FALSE)
# 外圈间隙：小刻度之间小间隙，组与组之间大间隙
gap_small <- 1.0    # 小扇区之间的空隙（单位：度）
gap_big   <- 6.0    # 大类之间的空隙
gap_after <- unlist(lapply(groups, function(genes){
n <- length(genes)
if (n == 1) gap_big else c(rep(gap_small, n-1), gap_big)
}), use.names = FALSE)
# =============== 3) 准备颜色 ===============
group_col <- c(
"Act. CD8+"="#F1A340","Eff. CD8+"="#92C5DE","Ccl5+ Eff. CD8+"="#999999",
"Dysf. CD8+"="#FDDBC7","cDC1"="#80CDC1","TAMs"="#8C6BB1",
"cDC2"="#FB8072","ActDC"="#66C2A5"
)
# 每个小扇区的颜色 = 对应大类颜色（可按需浅化/加透明）
grid_col <- setNames(
rep(group_col[names(groups)], lengths(groups)),
sector_order
)
# =============== 4) 把 link 映射到小扇区 ID ===============
id_from <- paste(links$from_group, links$from_gene, sep="|")
id_to   <- paste(links$to_group,   links$to_gene,   sep="|")
link_df <- data.frame(from=id_from, to=id_to, value=links$weight)
# 弦颜色用“来源大类”的颜色并加点透明
col_from_group <- sub("\\|.*$", "", link_df$from)
link_col <- adjustcolor(group_col[col_from_group], alpha.f = 0.6)
# 弦线宽度随权重线性缩放到 [1,6]
w <- link_df$value
lw <- 1 + 5 * (w - min(w)) / max(1e-8, (max(w) - min(w)))
# =============== 5) 画图 ===============
circos.clear()
circos.par(start.degree = 90, gap.after = gap_after,
track.margin = c(0.002, 0.002))
# 预留一条外圈 track 用来画“小刻度”和文字
chordDiagram(
x = link_df,
order   = sector_order,
grid.col= grid_col,
link.lwd= lw,
link.col= link_col,
transparency = 0.25,
annotationTrack = "grid",
preAllocateTracks = list(track.height = 0.10)
)
# =============== 1) 准备数据 ===============
# groups: 每个大类（细胞群）对应的基因列表（顺序即外圈小刻度顺序）
groups <- list(
"Act. CD8+"   = c("Tigit","Penk","Gnas","Cd47","Ccl3","Ccl4"),
"Eff. CD8+"   = c("Anxa2","B2m","Ccl3","Ccl5","Gzmb","Lef1","Itgal"),
"Ccl5+ Eff. CD8+" = c("Ccl5","Gzmb","Nkg7"),
"Dysf. CD8+"  = c("Anxa2","Ccl3","Ccl5","Gzmb","Lgals1"),
"cDC1"        = c("Amfr","Cd74","Dpp4","Ogfr"),
"TAMs"        = c("Trem2","Sirpa","Lsp1","Icam1","Tnf","Tnfrsf1b"),
"cDC2"        = c("Siglec1","Cd209","Nectin1","Icam1","Itgb2"),
"ActDC"       = c("Anxa2","App","Cd209","Icam1")
)
# 交互弦（示例；用你真实的互作/权重数据替换）
# from_gene / to_gene 的命名采用 "大类|基因" 形式以唯一标识小扇区
links <- data.frame(
from_group = c("TAMs","ActDC","cDC2","Eff. CD8+","Dysf. CD8+"),
from_gene  = c("Cd274","Icam1","Itgb2","Gzmb","Lgals1"),
to_group   = c("Eff. CD8+","cDC2","Act. CD8+","TAMs","ActDC"),
to_gene    = c("Pdcd1","Itgb2","Cd47","Cd274","Sirpa"),
weight     = c(0.55, 0.42, 0.38, 0.63, 0.30)
)
# =============== 2) 生成“小扇区”序列与间距 ===============
# 把每个基因变成一个 sector：  sector_id = "Group|Gene"
sector_ids_by_group <- lapply(names(groups), function(g){
paste(g, groups[[g]], sep="|")
})
names(sector_ids_by_group) <- names(groups)
sector_order <- unlist(sector_ids_by_group, use.names = FALSE)
# 外圈间隙：小刻度之间小间隙，组与组之间大间隙
gap_small <- 1.0    # 小扇区之间的空隙（单位：度）
gap_big   <- 6.0    # 大类之间的空隙
gap_after <- unlist(lapply(groups, function(genes){
n <- length(genes)
if (n == 1) gap_big else c(rep(gap_small, n-1), gap_big)
}), use.names = FALSE)
# =============== 3) 准备颜色 ===============
group_col <- c(
"Act. CD8+"="#F1A340","Eff. CD8+"="#92C5DE","Ccl5+ Eff. CD8+"="#999999",
"Dysf. CD8+"="#FDDBC7","cDC1"="#80CDC1","TAMs"="#8C6BB1",
"cDC2"="#FB8072","ActDC"="#66C2A5"
)
# 每个小扇区的颜色 = 对应大类颜色（可按需浅化/加透明）
grid_col <- setNames(
rep(group_col[names(groups)], lengths(groups)),
sector_order
)
# =============== 4) 把 link 映射到小扇区 ID ===============
id_from <- paste(links$from_group, links$from_gene, sep="|")
id_to   <- paste(links$to_group,   links$to_gene,   sep="|")
link_df <- data.frame(from=id_from, to=id_to, value=links$weight)
# 弦颜色用“来源大类”的颜色并加点透明
col_from_group <- sub("\\|.*$", "", link_df$from)
link_col <- adjustcolor(group_col[col_from_group], alpha.f = 0.6)
# 弦线宽度随权重线性缩放到 [1,6]
w <- link_df$value
lw <- 1 + 5 * (w - min(w)) / max(1e-8, (max(w) - min(w)))
# =============== 5) 画图 ===============
circos.clear()
circos.par(start.degree = 90, gap.after = gap_after,
track.margin = c(0.002, 0.002))
# 预留一条外圈 track 用来画“小刻度”和文字
chordDiagram(
x = link_df,
order   = sector_order,
grid.col= grid_col,
link.lwd= lw,
link.col= link_col,
transparency = 0.25,
annotationTrack = "grid",
preAllocateTracks = list(track.height = 0.10)
)
# 修正 1: 确保 order 与 grid.col 都包含完整扇区名
all_sectors <- unique(c(link_df$from, link_df$to))
# 修正 2: grid.col 命名为 sector_id（而非 group）
grid_col <- grid_col[intersect(names(grid_col), all_sectors)]
# 若有缺失则补齐颜色
missing <- setdiff(all_sectors, names(grid_col))
if (length(missing) > 0) {
grid_col[missing] <- "#CCCCCC"  # 灰色填补缺失项
}
# 修正 3: 更新 order
sector_order <- all_sectors
# 弦颜色用“来源大类”的颜色并加点透明
col_from_group <- sub("\\|.*$", "", link_df$from)
link_col <- adjustcolor(group_col[col_from_group], alpha.f = 0.6)
# 弦线宽度随权重线性缩放到 [1,6]
w <- link_df$value
lw <- 1 + 5 * (w - min(w)) / max(1e-8, (max(w) - min(w)))
# =============== 5) 画图 ===============
circos.clear()
circos.par(start.degree = 90, gap.after = gap_after,
track.margin = c(0.002, 0.002))
# 预留一条外圈 track 用来画“小刻度”和文字
chordDiagram(
x = link_df,
order   = sector_order,
grid.col= grid_col,
link.lwd= lw,
link.col= link_col,
transparency = 0.25,
annotationTrack = "grid",
preAllocateTracks = list(track.height = 0.10)
)
# =============== 6) 关键步骤：为每个小扇区画“刻度”与基因名 ===============
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y){
si   <- get.cell.meta.data("sector.index")     # 当前小扇区 ID: "Group|Gene"
xlim <- get.cell.meta.data("xlim")
ylim <- get.cell.meta.data("ylim")
grp  <- sub("\\|.*$", "", si)
gene <- sub("^.*\\|",  "", si)
# 小刻度：在最外侧画一条很窄的矩形条（厚度用 mm_y 保持物理尺寸稳定）
tick_h <- mm_y(1.2)   # 刻度高度（mm），可调
circos.rect(xleft = xlim[1], ybottom = ylim[2]-tick_h,
xright= xlim[2], ytop    = ylim[2],
col = adjustcolor(group_col[grp], alpha.f = 0.9),
border = NA)
# 基因名：放在扇区外侧，顺时针并自动转正
circos.text(x = (xlim[1]+xlim[2])/2, y = ylim[2] + mm_y(1.8),
labels = gene, facing = "clockwise", niceFacing = TRUE,
adj = c(0, 0.5), cex = 0.35)
})
setwd("D:/桌面/he")
gene <- readxl::read_excel('gene_count.xls')
setwd("D:/桌面/he")
gene <- readxl::read_excel('count.xlsx')
gene$GN <- str_extract(gene$gene_description, "(?<=GN=)[^ ]+")
library(stringr)
gene$GN <- str_extract(gene$gene_description, "(?<=GN=)[^ ]+")

## baocun
ggsave("gene.RData", gene)
